From 34f14350bd002d43592e1ef6f5442024ababed76 Mon Sep 17 00:00:00 2001
From: Pavel Raiskup <praiskup@redhat.com>
Date: Mon, 13 Feb 2012 17:55:07 +0100
Subject: [PATCH] Fix dead loop on extracting existing symlinks with the -k
 option.

---
 src/extract.c |  101 +++++++++++++++++++++++++++++++++++++-------------------
 1 files changed, 67 insertions(+), 34 deletions(-)

diff --git a/src/extract.c b/src/extract.c
index 947e3ed..7a1c05b 100644
--- a/src/extract.c
+++ b/src/extract.c
@@ -984,12 +984,22 @@ create_placeholder_file (char *file_name, bool is_symlink, int *interdir_made)
   struct stat st;
 
   while ((fd = open (file_name, O_WRONLY | O_CREAT | O_EXCL, 0)) < 0)
-    if (! maybe_recoverable (file_name, interdir_made))
-      break;
+    {
+      switch (maybe_recoverable (file_name, interdir_made))
+	{
+	case RECOVER_OK:
+	  continue;
+	  
+	case RECOVER_SKIP:
+	  return 0;
+	  
+	case RECOVER_NO:
+	  open_error (file_name);
+	  return -1;
+	}
+      }
 
-  if (fd < 0)
-    open_error (file_name);
-  else if (fstat (fd, &st) != 0)
+  if (fstat (fd, &st) != 0)
     {
       stat_error (file_name);
       close (fd);
@@ -1059,7 +1069,8 @@ extract_link (char *file_name, int typeflag)
 {
   int interdir_made = 0;
   char const *link_name;
-
+  int rc;
+  
   link_name = current_stat_info.link_name;
   
   if (! absolute_names_option && contains_dot_dot (link_name))
@@ -1099,8 +1110,10 @@ extract_link (char *file_name, int typeflag)
 
       errno = e;
     }
-  while (maybe_recoverable (file_name, &interdir_made));
+  while ((rc = maybe_recoverable (file_name, &interdir_made)) == RECOVER_OK);
 
+  if (rc == RECOVER_SKIP)
+    return 0;
   if (!(incremental_option && errno == EEXIST))
     {
       link_error (link_name, file_name);
@@ -1113,7 +1126,6 @@ static int
 extract_symlink (char *file_name, int typeflag)
 {
 #ifdef HAVE_SYMLINK
-  int status;
   int interdir_made = 0;
 
   if (! absolute_names_option
@@ -1121,15 +1133,22 @@ extract_symlink (char *file_name, int typeflag)
 	  || contains_dot_dot (current_stat_info.link_name)))
     return create_placeholder_file (file_name, true, &interdir_made);
 
-  while ((status = symlink (current_stat_info.link_name, file_name)))
-    if (!maybe_recoverable (file_name, &interdir_made))
-      break;
-
-  if (status == 0)
-    set_stat (file_name, &current_stat_info, NULL, 0, 0, SYMTYPE);
-  else
-    symlink_error (current_stat_info.link_name, file_name);
-  return status;
+  while (symlink (current_stat_info.link_name, file_name))
+    switch (maybe_recoverable (file_name, &interdir_made))
+      {
+      case RECOVER_OK:
+	continue;
+	
+      case RECOVER_SKIP:
+	return 0;
+	
+      case RECOVER_NO:
+	symlink_error (current_stat_info.link_name, file_name);
+	return -1;
+      }
+  
+  set_stat (file_name, &current_stat_info, NULL, 0, 0, SYMTYPE);
+  return 0;
 
 #else
   static int warned_once;
@@ -1155,16 +1174,23 @@ extract_node (char *file_name, int typeflag)
   mode_t invert_permissions =
     0 < same_owner_option ? mode & (S_IRWXG | S_IRWXO) : 0;
 
-  do
-    status = mknod (file_name, mode ^ invert_permissions,
-		    current_stat_info.stat.st_rdev);
-  while (status && maybe_recoverable (file_name, &interdir_made));
+  while (mknod (file_name, mode ^ invert_permissions,
+		current_stat_info.stat.st_rdev))
+    switch (maybe_recoverable (file_name, &interdir_made))
+      {
+      case RECOVER_OK:
+	continue;
+	
+      case RECOVER_SKIP:
+	return 0;
+	
+      case RECOVER_NO:
+	mknod_error (file_name);
+	return -1;
+      }
 
-  if (status != 0)
-    mknod_error (file_name);
-  else
-    set_stat (file_name, &current_stat_info, NULL, invert_permissions,
-	      ARCHIVED_PERMSTATUS, typeflag);
+  set_stat (file_name, &current_stat_info, NULL, invert_permissions,
+	    ARCHIVED_PERMSTATUS, typeflag);
   return status;
 }
 #endif
@@ -1180,15 +1206,22 @@ extract_fifo (char *file_name, int typeflag)
     0 < same_owner_option ? mode & (S_IRWXG | S_IRWXO) : 0;
 
   while ((status = mkfifo (file_name, mode)) != 0)
-    if (!maybe_recoverable (file_name, &interdir_made))
-      break;
+    switch (maybe_recoverable (file_name, &interdir_made))
+      {
+      case RECOVER_OK:
+	continue;
+	
+      case RECOVER_SKIP:
+	return 0;
+	
+      case RECOVER_NO:
+	mkfifo_error (file_name);
+	return -1;
+      }
 
-  if (status == 0)
-    set_stat (file_name, &current_stat_info, NULL, invert_permissions,
-	      ARCHIVED_PERMSTATUS, typeflag);
-  else
-    mkfifo_error (file_name);
-  return status;
+  set_stat (file_name, &current_stat_info, NULL, invert_permissions,
+	    ARCHIVED_PERMSTATUS, typeflag);
+  return 0;
 }
 #endif
 
-- 
1.7.4.4

